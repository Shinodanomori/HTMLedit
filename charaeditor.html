<!doctype html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SillyTavern Character Editor - V3 (Final)</title>
    <style>
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #6c757d;
            --background-color: #f4f7f9;
            --form-background-color: #ffffff;
            --text-color: #333;
            --label-color: #2c3e50;
            --border-color: #ced4da;
            --card-shadow: 0 6px 12px rgba(0,0,0,0.1);
            --header-color: #34495e;
            --section-bg: #fdfdfd;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1000px;
            margin: auto;
            background: var(--form-background-color);
            padding: 30px;
            border-radius: 12px;
            box-shadow: var(--card-shadow);
        }
        h1, h2, h3, h4 {
            color: var(--header-color);
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            margin-bottom: 25px;
        }
        h1 { text-align: center; }
        h4 {
            font-size: 1.2em;
            border-bottom: 1px solid #eaeaea;
            color: var(--primary-color);
        }
        .form-section {
            margin-bottom: 40px;
            padding: 25px;
            border-radius: 8px;
            background-color: var(--section-bg);
            border: 1px solid #e9ecef;
        }
        .form-group {
            margin-bottom: 25px;
        }
        label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--label-color);
            font-size: 1.1em;
        }
        .description {
            font-size: 0.9em;
            color: var(--secondary-color);
            margin-top: -5px;
            margin-bottom: 10px;
        }
        input[type="text"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-sizing: border-box;
            font-size: 1rem;
            transition: border-color 0.3s, box-shadow 0.3s;
            background-color: #fff;
        }
        input[type="text"]:focus,
        input[type="number"]:focus,
        textarea:focus,
        select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.2);
            outline: none;
        }
        textarea {
            min-height: 120px;
            resize: vertical;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }
        .button-group {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
            flex-wrap: wrap;
        }
        button {
            padding: 12px 25px;
            border: none;
            border-radius: 6px;
            background-color: var(--primary-color);
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        button:hover {
            background-color: #357ABD;
            transform: translateY(-2px);
        }
        button.secondary { background-color: var(--secondary-color); }
        button.secondary:hover { background-color: #5a6268; }
        .image-preview-container { text-align: center; }
        .image-preview {
            margin-top: 15px;
            max-width: 250px;
            max-height: 375px;
            border: 2px dashed var(--border-color);
            padding: 8px;
            border-radius: 8px;
            display: none;
        }
        .file-input-wrapper {
            border: 2px dashed #ccc;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            background-color: #fafafa;
            transition: background-color 0.3s, border-color 0.3s;
        }
        .file-input-wrapper:hover {
            background-color: #f0f0f0;
            border-color: var(--primary-color);
        }
    </style>
</head>
<body>

<div class="container">
    <h1>SillyTavern Character Editor <span style="font-size: 0.6em; color: var(--primary-color);">(V3)</span></h1>

    <div class="form-section">
        <h3><span style="color: var(--primary-color);">Step 1:</span> Load Character (Optional)</h3>
        <div class="form-group">
            <label for="file-loader">Load V1/V2/V3 Character Card (PNG or JSON)</label>
            <p class="description">既存のキャラクターを編集する場合は、ファイルをここにドラッグ＆ドロップするか、選択してください。</p>
            <div class="file-input-wrapper" id="drop-zone">
                <p>Drag & Drop a file here or click to select</p>
                <input type="file" id="file-loader" accept=".png, .json" style="display: none;">
            </div>
        </div>
    </div>

    <form id="character-editor">
        
        <div class="form-section">
            <h3><span style="color: var(--primary-color);">Step 2:</span> Edit Character</h3>
            
            <h4>Basic Information</h4>
            <div class="grid">
                <div class="form-group"><label for="name">Name</label><p class="description">キャラクターの名前。`{{char}}`として使用されます。</p><input type="text" id="name" required></div>
                <div class="form-group"><label for="nickname">Nickname</label><p class="description">`{{char}}`マクロをこの値で上書きします。空の場合はNameが使われます。</p><input type="text" id="nickname"></div>
                 <div class="form-group"><label for="creator">Creator</label><p class="description">キャラクターの作成者名。</p><input type="text" id="creator"></div>
                <div class="form-group"><label for="character_version">Character Version</label><p class="description">キャラクターのバージョン番号（例: 1.2）。</p><input type="text" id="character_version"></div>
            </div>
            <div class="form-group"><label for="tags">Tags</label><p class="description">キャラクターを分類するタグをカンマ区切りで入力。</p><input type="text" id="tags"></div>
            <div class="form-group"><label for="source">Source</label><p class="description">キャラクターカードの出典元URLやIDをカンマ区切りで入力。</p><input type="text" id="source"></div>

            <h4>Character Definition</h4>
            <div class="form-group"><label for="description">Description</label><p class="description">キャラクターの性格、背景、外見などの詳細な説明。AIのキャラクター理解の根幹となります。</p><textarea id="description"></textarea></div>
            <div class="form-group"><label for="personality">Personality</label><p class="description">キャラクターの性格の要約。キーワードをカンマ区切りで列挙するのが効果的です。</p><textarea id="personality" rows="3"></textarea></div>
            <div class="form-group"><label for="scenario">Scenario</label><p class="description">チャット開始時の状況設定。</p><textarea id="scenario" rows="3"></textarea></div>

            <h4>Greetings</h4>
            <div class="form-group"><label for="first_mes">First Message</label><p class="description">キャラクターからの最初の挨拶やセリフ。</p><textarea id="first_mes"></textarea></div>
            <div class="form-group"><label for="alternate_greetings">Alternate Greetings</label><p class="description">別の挨拶パターン。各挨拶を改行で区切ってください。</p><textarea id="alternate_greetings" placeholder="こんにちは！&#10;やあ、元気？"></textarea></div>
            <div class="form-group"><label for="group_only_greetings">Group-only Greetings</label><p class="description">グループチャットでのみ使用される挨拶。各挨拶を改行で区切ってください。</p><textarea id="group_only_greetings"></textarea></div>

            <h4>Prompting & Examples</h4>
            <div class="form-group"><label for="mes_example">Example Messages</label><p class="description">キャラクターの話し方や対話スタイルを示す会話例。各例は `&lt;START&gt;` で区切ります。</p><textarea id="mes_example" placeholder="<START>&#10;{{user}}: こんにちは&#10;{{char}}: こんにちは、何か御用ですか？"></textarea></div>
            <div class="form-group"><label for="system_prompt">System Prompt</label><p class="description">このキャラクター専用のシステムプロンプト。空欄の場合はSillyTavernのデフォルト設定が使われます。</p><textarea id="system_prompt"></textarea></div>
            <div class="form-group"><label for="post_history_instructions">Post History Instructions (Jailbreak)</label><p class="description">会話履歴の後に追加される指示（ジェイルブレイク）。空欄の場合はSillyTavernのデフォルト設定が使われます。</p><textarea id="post_history_instructions"></textarea></div>
            
            <h4>Advanced Features</h4>
            <div class="form-group"><label for="creator_notes">Creator's Notes</label><p class="description">作成者からユーザーへのメモ（英語）。この内容はプロンプトには含まれません。</p><textarea id="creator_notes" rows="3"></textarea></div>
            <div class="form-group"><label for="creator_notes_multilingual">Creator's Notes (Multilingual)</label><p class="description">多言語対応の作成者メモ。JSON形式で入力します (例: {"ja": "日本語のメモ"})。</p><textarea id="creator_notes_multilingual" placeholder='{&#10;  "ja": "これは日本語のノートです。",&#10;  "es": "Esta es una nota en español."&#10;}'></textarea></div>
            <div class="form-group"><label for="character_book">Character Book</label><p class="description">キャラクター固有のLorebook設定。有効なJSON形式で入力してください。</p><textarea id="character_book" rows="10" placeholder='{&#10;  "name": "My Lorebook",&#10;  "description": "Book description here.",&#10;  "scan_depth": 20,&#10;  "token_budget": 1024,&#10;  "recursive_scanning": false,&#10;  "extensions": {},&#10;  "entries": [&#10;    {&#10;      "keys": ["magic", "spell"],&#10;      "content": "Magic in this world is based on elemental forces.",&#10;      "extensions": {},&#10;      "enabled": true,&#10;      "insertion_order": 100,&#10;      "case_sensitive": false,&#10;      "use_regex": false&#10;    }&#10;  ]&#10;}'></textarea></div>
            <div class="form-group"><label for="assets">Assets</label><p class="description">アイコン、背景、表情などのアセット定義。有効なJSON形式の配列で入力してください。</p><textarea id="assets" rows="8" placeholder='[&#10;  {&#10;    "type": "icon",&#10;    "uri": "ccdefault:",&#10;    "name": "main",&#10;    "ext": "png"&#10;  },&#10;  {&#10;    "type": "emotion",&#10;    "uri": "embeded://assets/emotion/images/happy.png",&#10;    "name": "happy",&#10;    "ext": "png"&#10;  }&#10;]'></textarea></div>

            <h4>Extensions (Intuitive UI)</h4>
            <div class="grid">
                <div class="form-group">
                    <label for="ext_fav">Favorite</label>
                    <p class="description">キャラクターをお気に入りに設定します。</p>
                    <select id="ext_fav">
                        <option value="false" selected>False</option>
                        <option value="true">True</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="ext_talkativeness">Talkativeness</label>
                    <p class="description">キャラクターのおしゃべり度 (0.0-1.0)。</p>
                    <input type="number" id="ext_talkativeness" step="0.1" value="0.5">
                </div>
            </div>
            <div class="form-group">
                <label for="ext_world">World</label>
                <p class="description">キャラクターが存在する世界設定や背景情報。</p>
                <textarea id="ext_world" rows="4"></textarea>
            </div>
            <div style="padding: 20px; border: 1px solid var(--border-color); border-radius: 8px; margin-top: 20px;">
                <h4>Depth Prompt</h4>
                <div class="form-group">
                    <label for="ext_depth_prompt_prompt">Prompt</label>
                    <p class="description">キャラクターの行動規範や制約となるシステムプロンプト。</p>
                    <textarea id="ext_depth_prompt_prompt" rows="4"></textarea>
                </div>
                <div class="grid">
                    <div class="form-group">
                        <label for="ext_depth_prompt_depth">Depth</label>
                        <p class="description">プロンプトの重視度 (1-5+)。</p>
                        <input type="number" id="ext_depth_prompt_depth" value="4" min="0">
                    </div>
                    <div class="form-group">
                        <label for="ext_depth_prompt_role">Role</label>
                        <p class="description">プロンプトの役割 (通常はsystem)。</p>
                        <select id="ext_depth_prompt_role">
                            <option value="system" selected>system</option>
                            <option value="user">user</option>
                            <option value="assistant">assistant</option>
                        </select>
                    </div>
                </div>
            </div>
            <textarea id="extensions_raw" style="display: none;"></textarea>
            
            <h4>Image</h4>
            <div class="form-group">
                <label for="avatar">Character Avatar</label>
                <p class="description">キャラクターカードに使用するPNG画像を選択してください。</p>
                <button type="button" id="select-avatar-btn" class="secondary">Select Image...</button>
                <input type="file" id="avatar" accept="image/png" style="display: none;">
                <div class="image-preview-container">
                    <img id="avatar-preview" class="image-preview" alt="Avatar Preview">
                </div>
            </div>
        </div>
        
        <div class="form-section">
            <h3><span style="color: var(--primary-color);">Step 3:</span> Export</h3>
            <div class="button-group">
                <button type="button" id="export-png">Export as Character Card (PNG)</button>
                <button type="button" id="export-json">Export as JSON</button>
            </div>
        </div>
    </form>
</div>

<script>
// --- CRC32 Logic (unchanged) ---
var CRC32 = (() => {
    const table = new Int32Array(256);
    for(let i=256; i--;) {
        let c = i;
        for(let k=8; k--;) c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
        table[i] = c;
    }
    return {
        buf: (buf, crc = -1) => {
            for(let i=0; i < buf.length;) crc = table[(crc ^ buf[i++]) & 0xFF] ^ crc >>> 8;
            return ~crc;
        },
        str: (str, crc = -1) => CRC32.buf(new TextEncoder().encode(str), crc)
    };
})();

// --- PNG Logic (unchanged) ---
class PngGenerator {
    static #textEncoder = new TextEncoder();
    static #textDecoder = new TextDecoder("utf-8", { fatal: true });
    static #encodeText(keyword, text) {
        const keywordBytes = this.#textEncoder.encode(keyword);
        const textBytes = this.#textEncoder.encode(text);
        const data = new Uint8Array(keywordBytes.length + 1 + textBytes.length);
        data.set(keywordBytes);
        data.set(textBytes, keywordBytes.length + 1);
        return data;
    }
    static #readChunk(data, idx) {
        const view = new DataView(data.buffer);
        const length = view.getUint32(idx, false);
        idx += 4;
        const type = this.#textDecoder.decode(data.slice(idx, idx + 4));
        idx += 4;
        const chunkData = data.slice(idx, idx + length);
        idx += length;
        const crc = view.getInt32(idx, false);
        idx += 4;
        if (crc !== CRC32.buf(chunkData, CRC32.str(type))) console.warn(`CRC mismatch for chunk ${type}.`);
        return { type, data: chunkData, length, next_idx: idx };
    }
    static #readChunks(data) {
        const header = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
        for(let i=0; i<header.length; i++) if(data[i] !== header[i]) throw new Error('Invalid PNG header');
        const chunks = [];
        let idx = 8;
        while (idx < data.length) {
            const chunk = PngGenerator.#readChunk(data, idx);
            chunks.push(chunk);
            idx = chunk.next_idx;
        }
        return chunks;
    }
    static #encodeChunks(chunks) {
        const signature = new Uint8Array([0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]);
        const totalLength = 8 + chunks.reduce((acc, c) => acc + 12 + c.data.length, 0);
        const output = new Uint8Array(totalLength);
        const view = new DataView(output.buffer);
        output.set(signature, 0);
        let idx = 8;
        chunks.forEach(c => {
            view.setUint32(idx, c.data.length, false);
            idx += 4;
            output.set(this.#textEncoder.encode(c.type), idx);
            idx += 4;
            output.set(c.data, idx);
            idx += c.data.length;
            view.setInt32(idx, CRC32.buf(c.data, CRC32.str(c.type)), false);
            idx += 4;
        });
        return output;
    }
    static Generate(arrayBuffer, jsonString) {
        const uint8Array = new Uint8Array(arrayBuffer);
        const chunks = this.#readChunks(uint8Array).filter(c => c.type !== 'tEXt' || (this.#textDecoder.decode(c.data.slice(0, c.data.indexOf(0))) !== 'ccv3' && this.#textDecoder.decode(c.data.slice(0, c.data.indexOf(0))) !== 'chara'));
        const base64Encoded = btoa(new TextEncoder().encode(jsonString).reduce((data, byte) => data + String.fromCharCode(byte), ''));
        const charaChunk = { type: 'tEXt', data: this.#encodeText('ccv3', base64Encoded) };
        const iendIndex = chunks.findIndex(c => c.type === 'IEND');
        chunks.splice(iendIndex, 0, charaChunk);
        return this.#encodeChunks(chunks);
    }
    static Parse(arrayBuffer) {
        const uint8Array = new Uint8Array(arrayBuffer);
        const chunks = this.#readChunks(uint8Array);
        const findChunk = (name) => chunks.find(c => {
            if(c.type === 'tEXt') {
                const nullIdx = c.data.indexOf(0);
                if(nullIdx !== -1) return this.#textDecoder.decode(c.data.slice(0, nullIdx)) === name;
            }
            return false;
        });
        const targetChunk = findChunk('ccv3') || findChunk('chara');
        if (targetChunk) {
            const nullIdx = targetChunk.data.indexOf(0);
            const base64Data = this.#textDecoder.decode(targetChunk.data.slice(nullIdx + 1));
            try {
                const binaryString = atob(base64Data);
                const bytes = Uint8Array.from(binaryString, c => c.charCodeAt(0));
                return JSON.parse(new TextDecoder("utf-8").decode(bytes));
            } catch(e) {
                console.error("Failed to decode chara data:", e);
                throw new Error("Invalid character data in PNG.");
            }
        }
        throw new Error("No character data found in PNG.");
    }
}

// --- Main Application Logic ---
document.addEventListener('DOMContentLoaded', () => {
    const form = document.getElementById('character-editor');
    const fileLoader = document.getElementById('file-loader');
    const dropZone = document.getElementById('drop-zone');
    const avatarInput = document.getElementById('avatar');
    const selectAvatarBtn = document.getElementById('select-avatar-btn');
    const avatarPreview = document.getElementById('avatar-preview');
    let imageBuffer = null;

    const handleFile = (file) => {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (event) => {
            try {
                let data;
                if (file.type === 'application/json') {
                    data = JSON.parse(event.target.result);
                } else if (file.type === 'image/png') {
                    imageBuffer = event.target.result;
                    avatarPreview.src = URL.createObjectURL(file);
                    avatarPreview.style.display = 'block';
                    data = PngGenerator.Parse(event.target.result);
                } else {
                    alert("Unsupported file type. Please use PNG or JSON."); return;
                }
                populateForm(data);
            } catch (error) {
                console.error('Error loading file:', error);
                alert(`ファイルの読み込みに失敗しました: ${error.message}`);
            }
        };
        if (file.type === 'image/png') reader.readAsArrayBuffer(file);
        else reader.readAsText(file);
    };
    
    fileLoader.addEventListener('change', (e) => handleFile(e.target.files[0]));
    dropZone.addEventListener('click', () => fileLoader.click());
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.style.borderColor = 'var(--primary-color)'; });
    dropZone.addEventListener('dragleave', (e) => { e.preventDefault(); dropZone.style.borderColor = '#ccc'; });
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.style.borderColor = '#ccc'; handleFile(e.dataTransfer.files[0]); });

    function populateForm(cardData) {
        const data = cardData.data || cardData;
        
        ['name', 'description', 'personality', 'scenario', 'first_mes', 'mes_example', 'creator', 'character_version', 'nickname', 'creator_notes', 'system_prompt', 'post_history_instructions'].forEach(id => {
            form.elements[id].value = data[id] || '';
        });
        
        form.elements.tags.value = (data.tags || []).join(', ');
        form.elements.source.value = (data.source || []).join(', ');
        form.elements.alternate_greetings.value = (data.alternate_greetings || []).join('\n');
        form.elements.group_only_greetings.value = (data.group_only_greetings || []).join('\n');
        
        const stringify = (obj) => obj ? JSON.stringify(obj, null, 2) : '';
        form.elements.creator_notes_multilingual.value = stringify(data.creator_notes_multilingual);
        form.elements.character_book.value = stringify(data.character_book);
        form.elements.assets.value = stringify(data.assets);
        
        const extensions = data.extensions || {};
        const depthPrompt = extensions.depth_prompt || {};
        form.elements.ext_fav.value = extensions.fav ? 'true' : 'false';
        form.elements.ext_talkativeness.value = extensions.talkativeness || '0.5';
        form.elements.ext_world.value = extensions.world || '';
        form.elements.ext_depth_prompt_prompt.value = depthPrompt.prompt || '';
        form.elements.ext_depth_prompt_depth.value = depthPrompt.depth !== undefined ? depthPrompt.depth : 4;
        form.elements.ext_depth_prompt_role.value = depthPrompt.role || 'system';
        form.elements.extensions_raw.value = stringify(extensions);
        
        alert("キャラクターデータをフォームに読み込みました。");
    }

    selectAvatarBtn.addEventListener('click', () => avatarInput.click());
    avatarInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file && file.type === "image/png") {
            const bufferReader = new FileReader();
            bufferReader.onload = (e_buffer) => imageBuffer = e_buffer.target.result;
            bufferReader.readAsArrayBuffer(file);
            const dataUrlReader = new FileReader();
            dataUrlReader.onload = (event) => {
                avatarPreview.src = event.target.result;
                avatarPreview.style.display = 'block';
            };
            dataUrlReader.readAsDataURL(file);
        } else {
            alert('PNG形式の画像を選択してください。');
            avatarPreview.style.display = 'none';
            imageBuffer = null;
        }
    });

    function getFormData() {
        let baseExtensions = {};
        try {
            const rawExt = form.elements.extensions_raw.value.trim();
            if(rawExt) baseExtensions = JSON.parse(rawExt);
        } catch(e) { console.warn("Could not parse raw extensions. Custom extensions might be lost.", e); }

        Object.assign(baseExtensions, {
            fav: form.elements.ext_fav.value === 'true',
            talkativeness: form.elements.ext_talkativeness.value,
            world: form.elements.ext_world.value.trim(),
            depth_prompt: {
                prompt: form.elements.ext_depth_prompt_prompt.value.trim(),
                depth: parseInt(form.elements.ext_depth_prompt_depth.value, 10),
                role: form.elements.ext_depth_prompt_role.value
            }
        });
        
        const getJSON = (id) => {
            try {
                const val = form.elements[id].value.trim(); return val ? JSON.parse(val) : undefined;
            } catch { alert(`'${id}' のJSON形式が正しくありません。`); return undefined; }
        };

        const data = {
            name: form.elements.name.value.trim(),
            description: form.elements.description.value.trim(),
            personality: form.elements.personality.value.trim(),
            scenario: form.elements.scenario.value.trim(),
            first_mes: form.elements.first_mes.value.trim(),
            mes_example: form.elements.mes_example.value.trim(),
            creator: form.elements.creator.value.trim(),
            character_version: form.elements.character_version.value.trim(),
            tags: form.elements.tags.value.split(',').map(t => t.trim()).filter(Boolean),
            nickname: form.elements.nickname.value.trim() || undefined,
            creator_notes: form.elements.creator_notes.value.trim(),
            system_prompt: form.elements.system_prompt.value.trim(),
            post_history_instructions: form.elements.post_history_instructions.value.trim(),
            alternate_greetings: form.elements.alternate_greetings.value.split('\n').map(t => t.trim()).filter(Boolean),
            group_only_greetings: form.elements.group_only_greetings.value.split('\n').map(t => t.trim()).filter(Boolean),
            source: form.elements.source.value.split(',').map(t => t.trim()).filter(Boolean),
            creator_notes_multilingual: getJSON('creator_notes_multilingual'),
            character_book: getJSON('character_book'),
            assets: getJSON('assets'),
            extensions: baseExtensions,
            creation_date: Math.floor(Date.now() / 1000),
            modification_date: Math.floor(Date.now() / 1000),
        };
        
        Object.keys(data).forEach(key => data[key] === undefined && delete data[key]);

        return { spec: 'chara_card_v3', spec_version: '3.0', data: data };
    }

    function downloadFile(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename;
        document.body.appendChild(a); a.click();
        document.body.removeChild(a); URL.revokeObjectURL(url);
    }
    
    document.getElementById('export-json').addEventListener('click', () => {
        const charData = getFormData();
        const charName = charData.data.name || 'character';
        const jsonString = JSON.stringify(charData, null, 2);
        downloadFile(new Blob([jsonString], { type: 'application/json;charset=utf-8' }), `${charName}.json`);
    });

    document.getElementById('export-png').addEventListener('click', () => {
        if (!imageBuffer) { alert('キャラクターカードをエクスポートするには、まずPNG画像をアップロードしてください。'); return; }
        const charData = getFormData();
        const charName = charData.data.name || 'character';
        const jsonString = JSON.stringify(charData, null, 2);
        try {
            const newPngData = PngGenerator.Generate(imageBuffer, jsonString);
            downloadFile(new Blob([newPngData], { type: 'image/png' }), `${charName}.png`);
        } catch (error) {
            console.error('Error generating character card:', error);
            alert(`キャラクターカードの生成中にエラーが発生しました: ${error.message}`);
        }
    });
});
</script>

</body>
</html>